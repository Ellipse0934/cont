include core.cn
include os.cn
include stack.cn


proc sbrk int -> ptr:
  NULL brk dup rot ptr+ brk drop
end

proc time -> int:
  NULL timesys
end 


unpack struct str
  int len
  ptr data
end

proc puts @str: STDOUT write drop end 
proc input ptr -> @str: dup 1024 swap STDIN read swap end
proc println @str: puts "\n" puts end

nproc assert int cond @str:
  if cond not do
    len data puts
    -1 exit
  end
end

nproc cpy_buf int size ptr buf ptr des:
  0
  size 0 >
  while
    bind index: 
      buf index ptr+ @8
      des index ptr+ !8
      index 1 +
    end
    dup size < 
  end
  drop
end

// Synonym
proc memcpy int ptr ptr:
  cpy_buf
end

nproc memset ptr ptr int val int len:
  0
  len 0 >
  while
    bind index: 
      val ptr index ptr+ !8
      index 1 +
    end
    dup len < 
  end
  drop
end

// Sysnonym for backwards compitability
nproc clear_buf int len ptr ptr:
  ptr 0 len memset
end

struct MallocBlockMeta
  int size
  MallocBlockMeta next
  int is_free
end

proc get_malloc_meta ptr -> MallocBlockMeta:
  sizeoftype MallocBlockMeta ptr- (MallocBlockMeta)
end

var malloc_base *MallocBlockMeta
var malloc_last *MallocBlockMeta

nproc malloc int size -> ptr:
  malloc_base dup NULL ptr!= while  
    bind curr_block:    
      if curr_block.is_free curr_block.size size >= and do           
        if curr_block.size size - sizeoftype MallocBlockMeta > do      
          curr_block sizeoftype MallocBlockMeta ptr+ size ptr+ (MallocBlockMeta)        
          bind new_block:
            curr_block.size size - sizeoftype MallocBlockMeta - !new_block.size
            curr_block.next !new_block.next
            if new_block.next NULL ptr== do
              new_block !malloc_last
            end
            1 !new_block.is_free
            new_block !curr_block.next
            size !curr_block.size
          end
        end
        0 !curr_block.is_free
        curr_block sizeoftype MallocBlockMeta ptr+ 0
      else      
        if curr_block.next NULL ptr== do
          NULL 0
        else
          curr_block.next 1
        end
      end
    end
  end
  if dup NULL ptr== do  
    drop
    size sizeoftype MallocBlockMeta +
    sbrk (MallocBlockMeta) 
    dup NULL ptr!= if // Sbrk failed
      dup    
      size swap !.size    
      if malloc_last NULL ptr!= do      
        dup malloc_last !.next
      end    
      dup !malloc_last    
      if malloc_base NULL ptr== do
        dup !malloc_base
      end
    end
    sizeoftype MallocBlockMeta ptr+
  end
end

proc free ptr: 
  dup
  1 swap get_malloc_meta !.is_free
  dup get_malloc_meta .size swap clear_buf
end

proc u_to_str int -> @str:
  var index int
  21 !index
  22 malloc
  bind res:
    dup 0 == if
      48 res index ptr+ !8
      *index dec
    end 
    dup 0 !=
    while
      10 div 
      48 + // Get character from mod
      index res +ptr !8
      *index dec
      dup 0 !=
    end drop
    21 index -
    bind len:
      len res 1 index + ptr+ res cpy_buf
      len res
    end
  end
end

nproc int_to_str int value -> @str:
  value 0 < if 
    0 value - u_to_str 
    bind len ptr:
      22 malloc
      bind buf:
        len ptr buf 1 ptr+ cpy_buf // Shift u_to_str result and put into buf
        ptr free
        45 buf !8
        len 1 + buf
      end
    end
  else
    value u_to_str
  end
end

proc print int: 
  int_to_str dup rot swap println free
end

nproc str_to_int @str -> int:
  var res int
  0 !res
  0 while dup len < do
    dup data +ptr @8
    bind char:
      if char '0' < char '9' > or do
        "Non-digit character in str_to_int: " puts
        dup 1 swap data +ptr puts
        "\n" puts
        0 exit
      end 
      res 10 * !res
      *res char '0' - incby
      1 +
    end
  end drop
  res
end

// Debug procedure
proc print_malloc_list:
  malloc_base 1 
  while
    dup NULL ptr!= if 
      dup .size u_to_str dup rot swap puts free
      " -> " puts
      (MallocBlockMeta) .next 1
    else
      "NULL" println
      0
    end
  end drop
end

proc null_str_len ptr -> int:
  0 swap
  dup @8 0 !=
  while
    swap 1 +
    dup rot dup rot ptr+ @8 0 !=
  end drop
end

proc nstr_to_str ptr -> @str:
  dup null_str_len swap
end

nproc str_to_nstr @str -> ptr:
  len 1 + malloc
  bind buf:
    len data buf memcpy
    0 buf len ptr+ !8
    buf
  end
end

proc streq @str @str -> int:
  bind len data len2 data2:
    len2 len == if
      0 1
      len 0 >
      while
        drop
        bind curlen:
          curlen
          data curlen ptr+ @8
          data2 curlen ptr+ @8
          ==
        end
        bind curlen res:
          curlen 1 + res
          curlen 1 + len <
          res and
        end
      end
      swap drop
    else
      0
    end 
  end
end

nproc exec_cmd ptr argv ptr exec:
  var wstatus int
  fork
  bind  pid:
    pid 0 == if
      0 (ptr)
      argv
      exec
      execve drop
    else pid 0 > if
      0 (ptr)
      0
      *wstatus
      -1
      wait4 drop
    else
      "Fork failed\n" puts
      1 exit
    end end 
  end
end