include os.cn

proc / int int -> int: div drop end
proc % int int -> int: div swap drop end

proc ptr+ ptr int -> ptr:  swap  (int)      + (ptr) end
proc ptr- ptr int -> ptr:  swap  (int) swap - (ptr) end
proc +ptr int ptr -> ptr:        (int)      + (ptr) end
proc -ptr int ptr -> ptr:        (int)      - (ptr) end
proc ptr== ptr ptr -> int: (int) swap  (int) ==     end

proc NULL -> ptr: 0 (ptr) end

proc inc ptr:
  dup @int 1 + swap ! 
end
proc dec ptr:
  dup @int 1 - swap ! 
end
proc inc8 ptr:
  dup @8 1 + swap !8 
end
proc dec8 ptr:
  dup @8 1 - swap !8 
end

nproc incby ptr ptr int by:
  ptr @int by + ptr !
end
nproc decby ptr ptr int by:
  ptr @int by - ptr !
end
nproc inc8by ptr ptr int by:
  ptr @8 by + ptr !8
end
nproc dec8by ptr ptr int by:
  ptr @8 by - ptr !8
end

proc @16 ptr -> int:
  asm xor rax, rax
  asm pop rbx
  asm mov ax, [rbx]
  asm push rax
  (int) // Change ptr on type stack to int(ptr isn't on actual stack)
end
 
proc !16 int ptr:
  asm pop rbx
  asm pop rcx
  asm mov [rbx], cx
  
  // Make type checking up to date with stack
  asm push 0
  asm push 0
  drop drop
end

proc @32 ptr -> int:
  asm xor rax, rax
  asm pop rbx
  asm mov eax, [rbx]
  asm push rax
  (int) // Change ptr on type stack to int(ptr isn't on actual stack)
end
 
proc !32 int ptr:
  asm pop rbx
  asm pop rcx
  asm mov [rbx], ecx
  
  // Make type checking up to date with stack
  asm push 0
  asm push 0
  drop drop
end

proc sbrk int -> ptr:
  NULL brk +ptr brk
end

proc boolify int -> int: 0 != end

proc and int int -> int: boolify swap boolify + 1 >  end
proc or int int -> int:  boolify swap boolify + 0 >  end
proc not int -> int:     boolify 1 -  boolify        end
proc xor int int -> int: boolify swap boolify + 1 == end

unpack struct str
  int len
  ptr data
end

nproc 2duppi ptr a int b -> ptr int ptr int:
  a b a b
end
nproc 2dupip int a ptr b -> int ptr int ptr:
  a b a b
end

proc puts @str: STDOUT write drop end 
proc input ptr -> @str: dup 1024 swap STDIN read swap end
proc println @str: puts "\n" puts end

nproc assert int cond @str:
  if cond not do
    len data puts
  end
end

nproc cpy_buf int size ptr buf ptr des:
  0
  size 0 >
  while
    bind index: 
      buf index ptr+ @8
      des index ptr+ !8
      index 1 +
    end
    dup size < 
  end
  drop
end

nproc clear_buf int len ptr ptr:
  0
  len 0 >
  while
    bind index: 
      0 ptr index ptr+ !8
      index 1 +
    end
    dup len < 
  end
  drop
end

proc u_to_str int -> @str:
  var index int
  20 !index
  22 sbrk 
  bind res:
    dup 0 == if
      48 res index ptr+ !8
      *index dec
    end 
    dup 0 !=
    while
      10 div 
      48 + // Get character from mod
      index res +ptr !8
      *index dec
      dup 0 !=
    end drop
    20 index -
    res index 1 + ptr+
  end
end

nproc int_to_str int value -> @str:
  22 sbrk
  bind res:
    value 0 < if
      45 res !8
      0 value - u_to_str 
      bind len ptr:
        len ptr res 1 ptr+ cpy_buf
        len 1 + res
      end
    else
      value u_to_str
    end
  end
end

proc print int:
  int_to_str println
end

proc null_str_len ptr -> int:
  0 swap
  dup @8 0 !=
  while
    swap 1 +
    dup rot dup rot ptr+ @8 0 !=
  end drop
end

proc nstr_to_str ptr -> @str: dup null_str_len swap end

proc open2 int @str -> int:
  swap drop opensys2
end
proc open int int @str -> int:
  swap drop opensys
end
proc time -> int:
  NULL timesys
end 

proc streq @str @str -> int:
  bind len data len2 data2:
    len2 len == if
      0 1
      len 0 >
      while
        drop
        bind curlen:
          curlen
          data curlen ptr+ @8
          data2 curlen ptr+ @8
          ==
        end
        bind curlen res:
          curlen 1 + res
          curlen 1 + len <
          res and
        end
      end
      swap drop
    else
      0
    end 
  end
end

nproc exec_cmd ptr argv ptr exec:
  var wstatus int
  fork
  bind  pid:
    pid 0 == if
      0 (ptr)
      argv
      exec
      execve drop
    else pid 0 > if
      0 (ptr)
      0
      *wstatus
      -1
      wait4 drop
    else
      "Fork failed\n" puts
      1 exit
    end end 
  end
end